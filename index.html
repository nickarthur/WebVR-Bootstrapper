<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title></title>
    <script src="WebVRBootstrapper.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        html, body, #instructions, canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            margin: 0;
            border: 0;
            padding: 0;
            color:#c0c0c0;
        }

        #instructions {
            padding: 2em;
        }

        button {
            padding: 1em;
        }
    </style>
</head>
<body>
    <canvas></canvas>
    <div id="instructions">
        <h1>Loading...</h1>
        <div><progress style="width:100%"></progress></div>
        <h2>Choose your display type:</h2>
        <ul id="displays"></ul>
    </div>
    <script id="shader-fs" type="x-shader/x-fragment">
        void main(void) {
            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        void main(void) {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        }
    </script>
    <script>

        WebVRBootstrapper( [["../Primrose/PrimroseDependencies.min.js", 623878], ["../Primrose/Primrose.min.js", 219414]], function ( startDownload ) {
            var b = document.querySelector( "progress" ),
                d = document.querySelector( "#displays" ),
                h = document.querySelector( "h1" ),
                c = document.querySelector( "canvas" ),
                gl = c.getContext( "webgl" ),
                allDisplays = null,
                _currentDisplay = null,
                currentParameters = null,
                timer = null,
                sides = ["left", "right"];

            Object.defineProperty( window, "currentDisplay", {
                get: function () {
                    return _currentDisplay;
                },
                set: function ( v ) {
                    _currentDisplay = v;
                    currentParameters = getParams( _currentDisplay );
                    console.log( v );
                }
            } );

            function getParams( display ) {
                return sides.map( function ( side ) {
                    return display.getEyeParameters( side );
                } ).filter( function ( p ) { return p; } );
            }

            function getWidth( params ) {
                return params.map( function ( p ) {
                    return p.renderWidth;
                } ).reduce( function ( a, b ) {
                    return a + b;
                }, 0 );
            }

            function getHeight( params ) {
                return params.map( function ( p ) {
                    return p.renderHeight;
                } ).reduce( function ( a, b ) {
                    return Math.max( a, b );
                }, 0 );
            }

            function RAF( thunk ) {
                if ( timer ) {
                    timer.device.cancelAnimationFrame( timer.handle );
                    timer = null;
                }

                var width, height;
                if ( currentDisplay && currentDisplay.isPresenting ) {
                    timer = {
                        device: currentDisplay,
                        handle: currentDisplay.requestAnimationFrame( thunk )
                    };
                    currentParameters = getParams( currentDisplay );
                    width = getWidth( currentParameters );
                    height = getHeight( currentParameters );
                }
                else {
                    timer = {
                        device: window,
                        handle: window.requestAnimationFrame( thunk )
                    };
                    width = c.offsetWidth * devicePixelRatio;
                    height = c.offsetHeight * devicePixelRatio;
                }

                if ( c.width !== width || c.height !== height ) {
                    c.width = width;
                    c.height = height;
                }
            }

            navigator.getVRDisplays().then( function ( displays ) {
                allDisplays = displays;
                for ( var i = 0; i < displays.length; ++i ) {
                    var display = displays[i],
                        li = document.createElement( "li" ),
                        btn = document.createElement( "button" );
                    btn.type = "button";
                    btn.appendChild( document.createTextNode( display.displayName ) );
                    btn.addEventListener( "click", function ( disp ) {
                        currentDisplay = disp;
                        disp.requestPresent( [{ source: c }] );
                    }.bind( null, display ), false );
                    li.appendChild( btn );
                    d.appendChild( li );
                    if ( i === 0 ) {
                        currentDisplay = display;
                    }
                }
            } );

            window.addEventListener( "vrdisplaypresentchange", function ( evt ) {
                if ( currentDisplay && !currentDisplay.isPresenting ) {
                    currentDisplay = allDisplays[0];
                }
            } );

            startDownload( function ( obj ) {
                h.innerHTML = "All done";
            }, function ( n, m ) {
                b.max = m;
                b.value = n;
            } );

            function getShader( gl, id ) {
                var shaderScript, theSource, currentChild, shader;

                shaderScript = document.getElementById( id );

                if ( !shaderScript ) {
                    return null;
                }

                theSource = "";
                currentChild = shaderScript.firstChild;

                while ( currentChild ) {
                    if ( currentChild.nodeType == currentChild.TEXT_NODE ) {
                        theSource += currentChild.textContent;
                    }

                    currentChild = currentChild.nextSibling;
                }

                if ( shaderScript.type == "x-shader/x-fragment" ) {
                    shader = gl.createShader( gl.FRAGMENT_SHADER );
                } else if ( shaderScript.type == "x-shader/x-vertex" ) {
                    shader = gl.createShader( gl.VERTEX_SHADER );
                } else {
                    // Unknown shader type
                    return null;
                }
                gl.shaderSource(shader, theSource);
    
                // Compile the shader program
                gl.compileShader(shader);  
    
                // See if it compiled successfully
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
                    alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));  
                    return null;  
                }
    
                return shader;
            }

            var fragmentShader = getShader( gl, "shader-fs" );
            var vertexShader = getShader( gl, "shader-vs" );

            // Create the shader program

            shaderProgram = gl.createProgram();
            gl.attachShader( shaderProgram, vertexShader );
            gl.attachShader( shaderProgram, fragmentShader );
            gl.linkProgram( shaderProgram );

            // If creating the shader program failed, alert

            if ( !gl.getProgramParameter( shaderProgram, gl.LINK_STATUS ) ) {
                alert( "Unable to initialize the shader program: " + gl.getProgramInfoLog( shader ) );
            }

            gl.useProgram( shaderProgram );

            vertexPositionAttribute = gl.getAttribLocation( shaderProgram, "aVertexPosition" );
            gl.enableVertexAttribArray( vertexPositionAttribute );

            var vertices = [
              // Front face
              -1.0, -1.0, 1.0,
               1.0, -1.0, 1.0,
               1.0, 1.0, 1.0,
              -1.0, 1.0, 1.0,

              // Back face
              -1.0, -1.0, -1.0,
              -1.0, 1.0, -1.0,
               1.0, 1.0, -1.0,
               1.0, -1.0, -1.0,

              // Top face
              -1.0, 1.0, -1.0,
              -1.0, 1.0, 1.0,
               1.0, 1.0, 1.0,
               1.0, 1.0, -1.0,

              // Bottom face
              -1.0, -1.0, -1.0,
               1.0, -1.0, -1.0,
               1.0, -1.0, 1.0,
              -1.0, -1.0, 1.0,

              // Right face
               1.0, -1.0, -1.0,
               1.0, 1.0, -1.0,
               1.0, 1.0, 1.0,
               1.0, -1.0, 1.0,

              // Left face
              -1.0, -1.0, -1.0,
              -1.0, -1.0, 1.0,
              -1.0, 1.0, 1.0,
              -1.0, 1.0, -1.0
                        ];
                        var colors = [
              [1.0, 1.0, 1.0, 1.0],    // Front face: white
              [1.0, 0.0, 0.0, 1.0],    // Back face: red
              [0.0, 1.0, 0.0, 1.0],    // Top face: green
              [0.0, 0.0, 1.0, 1.0],    // Bottom face: blue
              [1.0, 1.0, 0.0, 1.0],    // Right face: yellow
              [1.0, 0.0, 1.0, 1.0]     // Left face: purple
            ];

            var generatedColors = [];

            for ( j = 0; j < 6; j++ ) {
                var c = colors[j];

                for ( var i = 0; i < 4; i++ ) {
                    generatedColors = generatedColors.concat( c );
                }
            }

            var cubeVerticesColorBuffer = gl.createBuffer();
            gl.bindBuffer( gl.ARRAY_BUFFER, cubeVerticesColorBuffer );
            gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( generatedColors ), gl.STATIC_DRAW );

            var cubeVerticesIndexBuffer = gl.createBuffer();
            gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer );

            // This array defines each face as two triangles, using the
            // indices into the vertex array to specify each triangle's
            // position.

            var cubeVertexIndices = [
              0, 1, 2, 0, 2, 3,    // front
              4, 5, 6, 4, 6, 7,    // back
              8, 9, 10, 8, 10, 11,   // top
              12, 13, 14, 12, 14, 15,   // bottom
              16, 17, 18, 16, 18, 19,   // right
              20, 21, 22, 20, 22, 23    // left
            ];

            // Now send the element array to GL

            gl.bufferData( gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array( cubeVertexIndices ), gl.STATIC_DRAW );

            RAF( function animate( dt ) {
                RAF( animate );
                if ( currentDisplay ) {
                    var left = 0,
                        pose = currentDisplay.getPose();
                    // Set clear color to black, fully opaque
                    gl.clearColor( 0.0, 0.0, 0.0, 1.0 );
                    // Enable depth testing
                    gl.enable( gl.DEPTH_TEST );
                    // Near things obscure far things
                    gl.depthFunc( gl.LEQUAL );
                    // Clear the color as well as the depth buffer.
                    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
                    for ( var i = 0; i < currentParameters.length; ++i ) {
                        var eye = currentParameters[i];
                        gl.viewport( left, 0, eye.renderWidth, eye.renderHeight );
                        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer );
                        //setMatrixUniforms();
                        gl.drawElements( gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0 );
                        left += eye.renderWidth;
                    }
                    if ( currentDisplay.isPresenting ) {
                        currentDisplay.submitFrame( pose );
                    }
                }
            } );
        } );
    </script>
</body>
</html>